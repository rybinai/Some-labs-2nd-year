/* 
 * Вычисление количества позиций символов для
 * символьного представления 32-битового целого числа
 *
 * Пограмма содержательно эквивалентна программе task1.S
 *
 * Компиляция: gcc -m32 -ggdb -o task1-exe-c task1.c
 *
 * -m32 генерировать 32 разрядные машинные команды

 * -ggdb - включить в исполняемый файл отладочную информацию

 * -o task1-exe-c - задание имени выходного (исполняемого) файла 

 * task1.c - исходныйx - входной файл (этот файл) 
 *
 * Запуск отладчика: kdbg task1-exe-c
 *
 * Получение asm текста, сгенерированного gcc: gcc -m32 -S -o task1-c.S task1.c
 *
 * -S - генерировать asm текст, не генерировать объектный и исп. файлы

 * -o task1-c.S - выходной файл программы на языке ассемблера 
 *            в которую gcc транслирует файл task1.c

 * task1.c - исходный - входной файл (этот файл)
*/

void main()
{                   
                  /*  соотв. конструкция ассемблера в 1.S и коммент. */
    int n = 2345;  /* n:      .long 2345  число */
    int length = 0;    /* length: .long 0     кол-во симв. позиций */

/*  Эти данные РАЗМЕЩАЕМ во встроенных в процессор
    целых 32 разрядных переменных - регистрах с фиксированными
    именами. ПОЭТОМУ ОПИСЫВАТЬ ИХ НЕ НАДО. Нет аналога в asm 
                           */ 
    int counter;   /* рег. %ebx - счетчик делений */
    int quotient;  /* будет в рег. %eax после деления - частное */
    int remainder; /* будет в рег. %edx после деления - остаток */

    quotient = n;  /* movl n, %eax  */
    counter = 0;   /* movl $0, %ebx */

nextdigit:
    remainder = quotient % 10; /* этот и следующий оператор
                                выполняются командой idivl ten 
*/
    quotient = quotient / 10;

    ++counter;               /* incl %ebx */   

    if (quotient) 
        goto nextdigit; 

/* проверка условия на ЯКЦП ВСЕГДА выполняется парой команд:

cmp <операнд1>, <операнд2> - вып. вычитание <операнд2>-<операнд1>
			- отражает знак и др. свойства результата
                          в битах регистра флагов.

 jcc <операнд> - j[ump on] c[ondition] c[ode] проверяет 
	условие в битах регистра флагов и по результату проверки  
	выполняет/не выполняет переход  по адресу <операнд>.

 В нашем случае команда jg   nextdigit { jg - jump if greater 
- перейти если строго  больше} выполняет переход на метку 
nextdigit: если предыдущая команда cmpl $0, %eax установила в 
регистре флагов биты, указывающие, что значение в  регистре %eax,
т.е. частное, СТРОГО  БОЛЬШЕ нуля.
*/ 
    length = counter; /* movl %ebx, length */
}
