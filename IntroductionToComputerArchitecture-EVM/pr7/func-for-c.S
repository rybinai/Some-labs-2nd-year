# Функции as , вызываемые из С

.globl	Numbers	# имя, ОПРЕДЕЛЕННОЕ вне этого исходного файла

.text # секция команд процесора

.type	Read_Sym, @function	# функция циклической обработки массива
.globl	Read_Sym		# имя может ИСПОЛЬЗОВАТЬСЯ вне этого исх. файла
Read_Sym:

/*
	Читает <Параметр1> символов из массива <Параметр2>
	и передает их на обработку функции Trans_Sym.
	Результат размещается в массив Numbers
*/

	# Стандартный пролог фунции

	pushl %ebp 	 # сохранить в стеке значение, бывшее в вызывающей
	movl  %esp, %ebp # обеспечить адресный доступ к параметрам и
			 # локальным переменнным в стеке путем базовой
			 # адресации через ebp

	subl  $4, %esp	 # завести 4-х байтовую локальную переменную

	# Тело функции

	subl %ecx, %ecx   # инициализация счетчика цикла
NextSym:
	movl 12(%ebp), %edx  # адрес второго параметра-массива в edx

	# вызов функции Trans_Sym

	subl %ebx, %ebx	     	    # подготовка ebx для записи символа
	movb (%edx,%ecx,1), %bl     # символ в ebx

	# Начинаем вызов Trans_Sym

	pusha		# сохранить регистры текущей функции Read_Sym

	pushl %ebx  	# Параметр функции Trans_Sym (код
			# символа из массива) в стек

	call Trans_Sym

	addl $4,%esp	# очистить стек от параметров Trans_Sym

	movl %eax, Numbers(,%ecx,4) 	# записать результат Trans-Sym

	popa	# восстановть регистры Read_Sym

	incl %ecx	     # наращиваем счетчик цикла
	cmpl 8(%ebp), %ecx   # счетчик равен первому параметру?
	jne NextSym	     # ДА, повторяем
			     # НЕТ - выходим из цикла

	# Стандартный эпилог функции

	movl %ebp, %esp # восстановить указатель стека
	popl %ebp       # восстановить ebp
	ret		# возврат в вызывающую

	# конец Read_Sym

/*
    Функция преобразования кода символа в числовое значение
    <Пареметр1> преобразуется в число и возвращается в eax
*/

.type	Trans_Sym, @function
.globl Trans_Sym
Trans_Sym:

	# Стандартный пролог фунции

	pushl %ebp 	 # сохранить в стеке значение, бывшее в вызывающей
	movl  %esp, %ebp # обеспечить адресный доступ к параметрам и
			 # локальным переменнным в стеке путем базовой
			 # адресации через ebp

	# тело функции

	movl 8(%ebp), %eax  # параметр в eax
	subl $'0', %eax    # получение числового значения

	# Стандартный эпилог функции

	movl %ebp, %esp # восстановить указатель стека
	popl %ebp       # восстановить ebp
	ret		# возврат в вызывающую


/*
 *  Функция суммирования одноцифровых чисел
 *  Считывает <Параметр1> (количество) чисел из массива Numbers
 *  и суммирует их. В качестве результата возвращает сумму
 *  одноцифровых чисел
**/
.type Sum_Num, @function
.globl Sum_Num
Sum_Num:

	# Пролог функции

	pushl %ebp
	movl %esp, %ebp

	subl %eax, %eax # Обнуляем регистр для результата %eax
	subl %ecx, %ecx # И обнуляем регистр счетчик %ecx

NextNum:

	addl Numbers(,%ecx,4), %eax  # Складываем число из массива Numbers с содержимым %eax

	incl %ecx                    # Счетчик увеличиваем на 1

	cmpl 8(%ebp), %ecx           # Проверяем, что прошли по всему содержимому
	jne NextNum

	# Эпилог функции

	movl %ebp, %esp
	popl %ebp
	ret

.end
